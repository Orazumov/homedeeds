try:
# тут тело программы - цикл..
except: ValueError as e:
    print('Ошибка! необходимо ввести число!')
    print(e)
    continue

# обработчики возм. ошибок.
# Если пользователь введет не число как мы ожидаем

abs() # ф. переводич чисило в плюс.
# в 5й задаче нужно пройти циклом и поставить новый элемент в
# рейтинг, при этом проверив след. элемент, а также через ф. abs,
#чтобы не было отриц.значений:

# задача 6 решается через ген. списков.

# Функции.

tmp = [1,2,3,4,5]

# требуется вычислять самое большое число из списка.
# в разных местах из разных списков.

# чтобы не писать для каждого списка свой код, пишут один раз ф.

# сущ. ф. max()   - max(tmp) = 5

# если дублируется код по функционалу, то пишут ф. Напишем нащу ф. max:

def my_max(iter: list) -> int: # параметр iter - потом какого типа ожидаем переменную.
    #-> int какого типа возвращаем данные.
    """
    Функция возвращает максимальный элемент списка
    :param iter:list # что принимает
    :return: int № что возвращает
    """
    # документация на функцию.
    result = None # если придет список меньше нуля, то если тут поставить 0, то он будет больше их всех.
    for itm in iter:
        if not result:
            result = itm
        if itm > result:
            result = itm
# ф. ничего не возвращает, по дефолту она возвр. None
    return result

print(my_max(tmp)) #вызвали ф.

# проверяем ф.

assert my_max([1,2,3,5]) == 5 # == тому, что ожидаем получить.

# Запускаем, если AssertionError - то неверно, если выплнилось - норм.

assert my_max([1,2,3,5]) == 5, 'ОШИБКА' # будет выдаваться при ошибке.

print(max.__doc__) # распечатывает доку по ф. она написана в '''   '''

# ф. может принимать много значений.

def my_max(iter: list, tmp,  any=12) -> int:
# any=12 - дефолтное значение, всегда стоит в конце.

return result, any

# если не стоит return - возвращается None.

# есть ф. sum([1,2,3]) = 6 - стандартная

def my_sum(*args):   # может принимать любое количество аргументов.
    result = 0

    for itm in args:
        result += itm

    return result

    print(typr(args)) # обращаемся без *. Класс tuple.

def my_car(**kwargs):
    result = ''
    for key, value in kwargs.items():
        result += f'{key}:{value}\n'
    return result

car1 = {
    'manufacture': 'Ford',
    'engine': 'BigBlock',
    'capacity': 8000,
}

car2 = {
    'manufacture': 'Tesla',
    'engine': 'electric',
    'capacity': None,
}

print(my_car(**car2))
# когда ставим ** - то словарь раскрывается и передается как именованные
# аргументы.
#мы можем передавать в ф. пременные в виде именованных элементов.
# kwargs внутри ф. - словать. произвольный.
# можно было передать и так:

print(my_car(manufacture='Tesla', engine='electric'))

# например, у нас есть список:

tmp = [1,2,3,4,5]

a,b = tmp

# пусть нам нужно чтобы a - первый элемент, b - второй элемент.

a,b,*c = tmp

# а = 1, b = 2, c = 3,4,5

a,*b,c = tmp

# а = 1, b = 5, c = 2, 3,4

# ф. map принимает в себя ф. и итер. объект. (список), прогоняет его через ф.
# и возвращает результат обработки списка этой ф.

def tmp(a):
    if a % 2:  # проверка четности
        return a
    return a**a

print(map(tmp, [2,3,4,5,6,7]))

#мап возвращ объект итератор, нужно преобразовать его к списку:

print(list(map(tmp, [2,3,4,5,6,7])))

# лямбда ф. - анонимные ф. они одноразовые, не имеют имен.

print(list(map(lambda a: a**a, [2,3,4,5,6,7])))
# lambda a: - что принимает, a**a - что возвращает..

# if a // 2:  # проверка четности -как сделать это в lambda?

print(list(map(lambda a: a if a % 2 else: a**a, [2,3,4,5,6,7])))
# использовали тернарный оператор. т.е в аноним ф. используем условия.
# лямбда работает быстрее, чем обычная ф.

temp = (lambda a, b: a ** b) (4,5) # (4,5) - передаем в ф. значения.

print(temp) # 1024

# область видимости.

test = 33
# переменная была определена ранее

def tmp_2(test):
    test = test + 1
    print(test)

tmp_2(22)

print(test)
# 23
# 33

def tmp_2(test):
    global test
    test = 14
    print(test)

# если хотим поменять глобальную переменную из ф.

# декораторы: обычная ф, которая на вх. принимает др. ф, что-то делает и возвр результат.
# модифицирует код.

def my_deco(func):
    def inner_deco(*args):
        print('Сначала я сделаю что-то свое')
        result = func(*args)
        print('После выполнения докор. функции')
        return result
    return inner_deco
# my deco подменил ф. my_max ф-цией inner_deco, изменив т.о. my_max, запомнив ее.
@my_deco  # интерпретатор передаст ф. my_max внутрь my_deco
def my_max(iter: list) -> int: # параметр iter - потом какого типа ожидаем переменную.
    #-> int какого типа возвращаем данные.
    """
    Функция возвращает максимальный элемент списка
    :param iter:list # что принимает
    :return: int № что возвращает
    """
    # документация на функцию.
    result = None # если придет список меньше нуля, то если тут поставить 0, то он будет больше их всех.
    for itm in iter:
        if not result:
            result = itm
        if itm > result:
            result = itm
# ф. ничего не возвращает, по дефолту она возвр. None
    return result

# используется в логировании, если нужно изменить ф. не переписывая ее.






