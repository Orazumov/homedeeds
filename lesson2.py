#DZ со временем.

#print(f'{sec_time//3600} - {sec_time % 3600 // 60} - {sec_time % 3600 % 60}')

#любой тип данных в Питоне - экземпляр класса и у него есть опред. методы,
#который можно использовать.
#

# проверяем является ли введенное значение числом или десятичным числом прежде чем преобразовать в int,
# иначе если запустить int на строку, то будет ошибка.
if proceeds.isdigit()
if proceeds.isdecimal()
# всегда проверяем типы данных прежде чем их преобразовать!

#Что есть строка, какие у нее свойства.

#STR это и 'a' и 'frgergerger' и '' - все сразу.

#задаем строку:

var_str = ''

# str не изменяемый тип данных, в памяти ее не изменить.

a = 'frefrfrferr'
type (a) # class str
id(a) #454624654 - адрес в памяти

a = a + 'rverre'

id(a)

# изменился указатель - результат выполн. id(a) - т.е. строка не изменилась, а создалась
#новая строка.
#старая строка через какое-то время удаляется, используется встроенный механизм garbadge collector

b = '1 2 3 4 5'

c = b.split(' ')  # метод, который возвращает список, в скобках - разделитель

print(c)

#['1', '2', ...]

g = ' '.join(c)

#g = '1 2 3 4 5' обратная операция к сплит.

#Индексы и срезы.

var_str = 'слово которое тут написано'
#хотим узнать 3ю букву в слове
var_str[2] #- 3й символ, начало с 0. Пробел и перенос строки - тоже символы.
#хотим взять первые 6 символов, использует срез.
var_str[0:1] # 'c'
var_str[0:2] # 'сл'

#var_str[start, end, step]

var_str[0:6:2] # 'соо'

var_str[:6] # c 0 до 6

var_str[::2] # вся строка с шагом 2.
#если пропущено - подставляются дефолтные значения.
# начало 0, конец - последний символ, шаг 1.

var_str[-1] # последний символ строки. строка как бы зациклена.
# можно и -2, -3 и т.д.

var_str[::-1] # взяли строку в обратном направлении.

# длина строки:

len(var_str) # считает количество символов, не передает индекс последнего знака.

var_str[27] # при том что в строке 26 символов.
# будет index error

# как отделить пробел:
temp = '1200 руб'

tmp = temp.split(' ')

#['1200', 'руб'] - получился список

#список как и строка - итерируемые объекты, можно ходить циклом for  и сов. итерации.

type(tmp) # class list

#для объявления списка не нужно указывать какого количества данные внутри.
#списки изменяемы, произвольного размера, итерируемы, т.е. можно применять индексы и срезы.

tmp[0] # 1200. задача решена.

# или же tmp = tmp.split(' ')[0]

# бывают многомерные списки:

# [1,2 [1,2 [1,2, 1,2 [[[1,2]]]]]]

#объявление списка:

lst_1 = []
lst_2 = list()

# строка в список:

var_str = 'строка'
list('строка')
#['c', 'т', 'р', 'о', 'к', 'а']

#список изменяемый:

tmp = [1,2,3]

id(tmp)

tmp.append(22) #добавили 22 в конец

# если tmp = tmp.append(22) - вернется NONE!! так нельзя делать! просто


id(tmp)
#не изменился! т.е. объект изменяемый.

#Следствие:

a = 'строка'
b = 'строка'

a == b

# True

a is b # оператор is проверяет соответствие. являются ли объекты одним объектом в памяти

b = a

a is b
#True

a = 1
b = 2

# int - не изм. объект как и строка.
a = b

a is b
#True т.к. целые числа не изм.

a = [1,2,3]
b = [1,2,3]

a == b
#True

a is b
# False - это разные объекты в памяти.

# например
c = a

#пользуемся этой с и хотим узнать тот ли это объект или нет

a is c
#True

b.pop() # удаляет посл. элемент и возвр. его

tmp = [1,2,3]
tmp = append(tmp)

tmp

#[1,2,3, [...]] - бесконечный список, рекурсивный.

len(tmp)
# 4
len(tmp[-1])
# 4

tmp is tmp[-1]
#True
# т.к. мы передаем ему ссылки на объект, а не сам объект, ссылку на самого себя, поэтому
#место в памяти то же.

# Циклы for.

lst_1 = [1,2,3,4]

for itm in lst_1:
    print(itm)

# каждую итерацию itm приобретает значение из итератора (lst_1)

for idx, itm in enumerate(lst_1, 0):

# по принт возвращается индекс элемента и сам список, enumerate возвращает кортежи, где индекс и элемент на 1 и 2 месте.
# enumerate - считает индекс элемента c инкриментом после , в скобках.

# никогда не изменяйте список по которому итерируетесь.

for itm in lst_1:
    print(f'{itm}')
    lst_1.append('1233')

# бесконечный цикл.

for itm in lst_1[:]:
    print(f'{itm}')
    lst_1.append('1233')
# взяли срез, так можно, т.к. срез - это поверхностная копия, не deepcopy.

a = 'строка это тут'
a.title()
#'Строка Это Тут
a.upper()
#СТРОКА ЭТО ТУТ
a.lower()
#строка это тут
a.replace('О', 'r') # что на что меняем

# задачка

var_str = 'эт3о как43ая-то стро1ка'

# выделим числа

result = []
for itm in var_str:
    if itm.isdigit():
        result.append(itm)
result = int(''.join(result)) # чтобы снова получить строку и из нее число.
print(result)

#Tuple - кортеж.

# Это список, который неизменяемый.
#меньше памяти занимает, никто не может изменить, есть срезы, индексы.
var_tuple = () # так кортежа не получится, т.к. это м.б. мат.выр.

var_tuple = (1,) # д.б. запятая, иначе это будет просто 1.

#пустой:

var_tuple = tuple() # это ф. преобраз в кортеж.

#Множества, SET

var_set = {1,2,3,4,5,4,32,1}

# может содержать только уникальные элементы и не гарантирует сохранение последовательности.
# в отличие от списков и кортежей.
# нельзя исп. индексы.

var_set.add(222) #добавили

# Frozen set - неизменяемое множество.

# можно делать цикл

for itm in var_set:
    print(itm)

set([1,2,4,5]) # преобразование списка в множество.
tuple(var_set) # множество в кортеж

var_set.difference(var_set2) # смотрим отличие множеств.

var_set.intersection(var_set2) # общие элементы.

# оператор in

3 in var_set
#True
5 in var_set
#False
# это применимо и к спискам, кортежам, строкам и т.д.

#Словарь DICT.

# объявляем

var_dict = {'key1':'value', 'key2':'value2'} #строка, число м.б. ключем

#можно идти циклом по словарю

var_dict['key1'] # обращение к элементу словаря.

# ключи д.б. разные, фактически набор ключей - set.

var_dict.items() - список всего - список кортежей из 2х элементов.
var_dict.keys() - список ключей
var_dict.values() - список всех значений

# ключ д.б. не изм тип данных - число, кортеж, строка, булевое, тапл.
#(хэшируемые)
#при этом value м.б. любого типа

#обращение к вложенным
tmp = {(1,2,3):[1,2,3,{4:222, 5:666}]}

tmp[(1,2,3)][0]
# 1
tmp[(1,2,3)][3][4] # неявно 4 - индекс или ключ, до конца непонятно. лучше так не делать.
# 222

for itm in var_dict:
    print(itm)
# перечиляем ключи

for key, value in var_dict.items():
    print(key, value)
#перечисл ключи и значения
tmp = (1,2,3)
a,b,c = tmp
# a = 1, b = 2, c = 3, так же со списком.

a = 1,2,3 # результат - кортеж.

# также аккуратно если идем циклом по словарю и его же меняем!

tmp = (('frfre', 123), ('311', '231312'))

dict(tmp)

>>> d = dict([(1, 1), (2, 4)])
>>> d
{1: 1, 2: 4}

# в результате словарь, где первый элемент ключ, второй - значение.













